/*将最轻的礼物与最重的礼物配对是尝试填满每一组容量的最好尝试。如果最轻和最重的礼物不能组合在一起，那么最重的礼物必然需要单独分配到一组中，
 因为它无法与任何其他的礼物组合而不超过重量限制。这样，通过每次循环减少至少一个礼物（有时是两个），直到所有礼物都被分配到组中*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+9;
int a[N]; // 定义数组a来存储每件礼物的重量

int main() {
  int w, n; // w是每组的重量限制，n是礼物的总数
  cin >> w >> n; // 读入w和n的值
  for (int i = 1; i <= n; i++) {
    cin >> a[i]; // 读入每件礼物的重量
  }
  sort(a+1, a+1+n); // 将礼物按重量升序排序

  int l = 1, r = n, ans = 0; // 使用双指针技术，l指向最轻的礼物，r指向最重的礼物
  while (l <= r) { // 当左指针小于等于右指针时继续循环
    ans++; // 无论如何，当前操作至少会使组数增加1
    if (l == r) { // 如果l和r指向同一个元素，说明所有的礼物都已考虑，结束循环
      break;
    }
    if (a[l] + a[r] <= w) { // 如果最轻和最重的礼物总重量小于等于w
      l++; // 将这两个礼物作为一组，移动左指针向右
      r--; // 移动右指针向左
    } else { // 如果最轻和最重的礼物总重量大于w
      r--; // 只将最重的礼物作为一组，移动右指针向左
    }
  }
  cout << ans << endl; // 输出最少的组数
  return 0;
}
